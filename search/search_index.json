{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"refcount - Python classes for reference counting","text":"<p>This package is primarily for managing resources in native libraries, written for instance in C++, from Python. While it boils down to \"simply\" maintaining a set of counters, it is deceptively complicated to do so properly and not end up with memory leaks or crashes. This package offers structured options for reliably managing external native resources. Surprisingly I could not locate an existing package doing just what I needed. Other use cases requiring reference counting, aside from native library resources, may benefit from reusing and extending classes in <code>refcount</code>.</p> <p><code>refcount</code> ( &gt;=0.7) includes classes using cffi. Other low-level interoperability mechanisms may well be added in the future.</p>"},{"location":"#license","title":"License","text":"<p>MIT (see License.txt)</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Hosted at refcount via readthedocs.io</p>"},{"location":"#source-code","title":"Source code","text":"<p>The code repository is on GitHub.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#conda-forge","title":"conda-forge","text":"<p>Using <code>conda</code> or <code>mamba</code>:</p> <pre><code>mamba install -c conda-forge refcount\n</code></pre>"},{"location":"#pypi","title":"pypi","text":"<pre><code>pip install refcount\n</code></pre>"},{"location":"#from-source-development","title":"From source (development)","text":"<pre><code>pip install -r requirements.txt\npip install -e .\n</code></pre>"},{"location":"#sample-use","title":"Sample use","text":"<p>The following example is based on one of the unit tests.</p> <p>Say we have a C++ library with objects and a C API:</p> <pre><code>#define TEST_DOG_PTR  testnative::dog*\n#define TEST_OWNER_PTR  testnative::owner*\n#define TEST_COUNTED_PTR  testnative::reference_counter*\n\ntestnative::dog* create_dog();\ntestnative::owner* create_owner(testnative::dog* d);\nvoid say_walk(testnative::owner* owner);\nvoid release(testnative::reference_counter* obj);\n// etc.\n</code></pre> <p>From the outside of the library the API is exported with opaque pointers <code>void*</code> (C structs pointers and native C99 types could be handled too).</p> <pre><code>void* create_dog();\nvoid* create_owner(void* d);\nvoid say_walk(void* owner);\nvoid release(void* obj);\n// etc.\n</code></pre> <p>Starting with the end in mind, from Python we want an API hiding the low level details close to the C API, in particular avoiding managing native memory via <code>release</code> C API calls, piggybacking the python GC instead.</p> <pre><code>dog = Dog()\nowner = DogOwner(dog)\nowner.say_walk()\nprint(dog.position)\ndog = None # the \"native dog\" is still alive though, as the owner incremented the ref count\nowner = None\n</code></pre> <p>This is doable with <code>refcount</code> and the <code>cffi</code> package. One possible design is:</p> <pre><code>ut_ffi = cffi.FFI()\n\nut_ffi.cdef('extern void* create_dog();')\nut_ffi.cdef('extern void* create_owner( void* d);')\nut_ffi.cdef('extern void say_walk( void* owner);')\nut_ffi.cdef('extern void release( void* obj);')\n# etc.\n\nut_dll = ut_ffi.dlopen('c:/path/to/test_native_library.dll', ut_ffi.RTLD_LAZY) # Lazy loading\n\nclass CustomCffiNativeHandle(CffiNativeHandle):\n    def __init__(self, pointer, prior_ref_count = 0):\n        super(CustomCffiNativeHandle, self).__init__(pointer, type_id='', prior_ref_count = prior_ref_count)\n\n    def _release_handle(self) -&gt; bool:\n        ut_dll.release(self.get_handle())\n        return True\n\nclass Dog(CustomCffiNativeHandle):\n    def __init__(self, pointer = None):\n        if pointer is None:\n            pointer = ut_dll.create_dog()\n        super(Dog, self).__init__(pointer)\n    # etc.\n\nclass DogOwner(CustomCffiNativeHandle):\n\n    def __init__(self, dog):\n        super(DogOwner, self).__init__(None)\n        self._set_handle(ut_dll.create_owner(dog.get_handle()))\n        self.dog = dog\n        self.dog.add_ref() # Do note this important reference increment\n\n    def say_walk(self):\n        ut_dll.say_walk(self.get_handle())\n\n    def _release_handle(self) -&gt; bool:\n        super(DogOwner, self)._release_handle()\n        # super(DogOwner, self)._release_handle()\n        self.dog.release()\n        return True\n</code></pre>"},{"location":"#related-work","title":"Related work","text":""},{"location":"#ancestry-acknowledgements","title":"Ancestry, acknowledgements","text":"<p>This python package <code>refcount</code> actually spawned from prior work for interoperability between C++, R and .NET (R.NET)</p> <p><code>refcount</code> features using <code>cffi</code> were also significantly informed by Kevin Plastow's work while he was at the Australian Bureau of Meteorology; this contribution is gratefully acknowledged.</p> <p>In you have native interop needs you may also want to look at:</p> <ul> <li>the nuget package dynamic-interop-dll for .NET/native interop.</li> <li>a set of mostly c++ software tools for interop with C/C++</li> <li>a C# library for generating interop glue code on top of C API glue code.</li> </ul>"},{"location":"#other-python-packages","title":"Other python packages","text":"<p><code>refcount</code> was created in part because no existing prior (Python) work could quite fit the need. There are however packages that may better address your particular need:</p> <ul> <li>infi.pyutils contains a reference counting class.</li> </ul>"},{"location":"#development-branch","title":"Development branch","text":""},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v127-2025-01-14","title":"v1.2.7 - 2025-01-14","text":"<p>Compare with v1.2.6</p>"},{"location":"changelog/#build","title":"Build","text":"<p>Functionally unchanged, the package has been migrated away from using <code>poetry</code> and some legacy steps for building to the template copier-uv.</p> <ul> <li>update cffi dependency version to the latest. Building older cffi fails on GH actions (e4e603d by J-M).</li> <li>cumulative changes until <code>make check</code> passes (ccf1a18 by J-M).</li> </ul>"},{"location":"changelog/#v126-2024-11-05","title":"v1.2.6 - 2024-11-05","text":"<p>Compare with v1.2.5</p> <ul> <li>Use proper ffi.RTLD_LAZY flag with cffi, in the unit tests. Related issue was noticed in moirai/issues/1, rather than <code>refcount</code> per se.</li> </ul>"},{"location":"changelog/#v125-2024-11-01","title":"v1.2.5 - 2024-11-01","text":"<p>Compare with v1.2.0</p> <ul> <li>Support wrapper generation with 4 parameter constructors for backward compat with swift wrappers.</li> <li>cumulative dependency updates</li> <li>increased unit test coverage</li> </ul>"},{"location":"changelog/#v120-2023-01-25","title":"v1.2.0 - 2023-01-25","text":"<p>Compare with v1.1.1</p>"},{"location":"changelog/#build_1","title":"Build","text":"<p><code>wrap_as_pointer_handle</code> wraps <code>None</code> via a <code>GenericWrapper</code>, to facilitate code generation on top of a C API allowing <code>nullptr</code> to be passed in.</p>"},{"location":"changelog/#v111-2022-08-19","title":"v1.1.1 - 2022-08-19","text":"<p>Compare with v1.1.0</p>"},{"location":"changelog/#build_2","title":"Build","text":"<p>Minor changes that may not have been required to build the conda package</p>"},{"location":"changelog/#v110-2022-08-19","title":"v1.1.0 - 2022-08-19","text":"<p>Compare with v1.0.0</p>"},{"location":"changelog/#build_3","title":"Build","text":"<ul> <li>Expand some features to cater for macos</li> <li>Tidy up and reengineer some of the legacy functions in the platform utilities <code>putils</code> to facilitate library loading. Minor breaking changes, but probably for no-one but the author in effect.</li> </ul>"},{"location":"changelog/#v100-2022-08-13","title":"v1.0.0 - 2022-08-13","text":"<p>Compare with v0.9.3</p>"},{"location":"changelog/#build_4","title":"Build","text":"<ul> <li>Improve documentation, and use the mkdocs-material theme</li> <li>mkdocs.yml changes. Enable dark/light modes from mkdocs-material</li> <li>Improved type hints, and add static type checks (mypy)</li> <li>Improve unit tests and add unit test code coverage reporting</li> <li>Manage the package using poetry; phase out setuptools.</li> <li>Apply some of the approaches in https://py-pkgs.org.</li> <li>Restore appveyor CI to a working state</li> </ul>"},{"location":"changelog/#v093-2022-01-24","title":"v0.9.3 - 2022-01-24","text":"<p>Compare with 0.9.1</p>"},{"location":"changelog/#feature","title":"Feature","text":"<ul> <li>Add a class CffiWrapperFactory</li> </ul>"},{"location":"changelog/#091-2021-04-07","title":"0.9.1 - 2021-04-07","text":"<p>Compare with 0.9</p>"},{"location":"changelog/#09-2021-03-09","title":"0.9 - 2021-03-09","text":"<p>Compare with 0.8</p>"},{"location":"changelog/#08-2021-01-11","title":"0.8 - 2021-01-11","text":"<p>Compare with 0.6.2</p>"},{"location":"changelog/#062-2019-01-03","title":"0.6.2 - 2019-01-03","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#060-2019-01-02","title":"0.6.0 - 2019-01-02","text":"<p>Compare with 0.5.1</p>"},{"location":"changelog/#051-2018-12-19","title":"0.5.1 - 2018-12-19","text":"<p>Compare with 0.5</p>"},{"location":"changelog/#05-2018-12-19","title":"0.5 - 2018-12-19","text":"<p>Compare with first commit</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at jean-michel.perraud@csiro.au. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd pyrefcount\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install uv manually.</p> <p>You can install it with:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>uv sync</code>.</p> <p>You now have the dependencies installed.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>The entry-point to run commands and tasks is the <code>make</code> Python script, located in the <code>scripts</code> directory. Try running <code>make</code> to show the available commands and tasks. The commands do not need the Python dependencies to be installed, while the tasks do. The cross-platform tasks are written in Python, thanks to duty.</p> <p>If you work in VSCode, we provide an action to configure VSCode for the project.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-1--credits","title":"Credits","text":"<p>These projects were used to build refcount. Thank you!</p> <p>Python | uv | copier-uv</p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License cffi Foreign Function Interface for Python calling C code. <code>&gt;=1.17, &gt;=1.12</code> <code>1.17.1</code> MIT pycparser C parser in Python <code>2.22</code> BSD-3-Clause"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License appdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=1.4</code> <code>1.4.4</code> MIT babel Internationalization utilities <code>&gt;=2.7.0</code> <code>2.16.0</code> BSD-3-Clause black The uncompromising code formatter. <code>&gt;=24.4</code> <code>24.10.0</code> MIT build A simple, correct Python build frontend <code>&gt;=1.2</code> <code>1.2.2.post1</code> MIT License certifi Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2024.12.14</code> MPL-2.0 cffi Foreign Function Interface for Python calling C code. <code>&gt;=1.17, &gt;=1.12</code> <code>1.17.1</code> MIT charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&gt;=2, &lt;4</code> <code>3.4.1</code> MIT click Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.8</code> BSD License colorama Cross-platform colored terminal text. <code>&gt;=0.4</code> <code>0.4.6</code> BSD License coverage Code coverage measurement for Python <code>&gt;=7.5</code> <code>7.6.10</code> Apache-2.0 cryptography cryptography is a package which provides cryptographic recipes and primitives to Python developers. <code>&gt;=2.0</code> <code>44.0.0</code> Apache-2.0 OR BSD-3-Clause csscompressor A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD docutils Docutils -- Python Documentation Utilities <code>&gt;=0.21.2</code> <code>0.21.2</code> Public Domain + Python Software Foundation License + BSD License + GNU General Public License (GPL) duty A simple task runner. <code>&gt;=1.4</code> <code>1.4.3</code> ISC execnet execnet: rapid multi-Python deployment <code>&gt;=2.1</code> <code>2.1.1</code> MIT failprint Run a command, print its output only if it fails. <code>&gt;=0.11, !=1.0.0</code> <code>1.0.3</code> ISC ghp-import Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. <code>&gt;=2.5</code> <code>2.5.3</code> ISC gitdb Git Object Database <code>&gt;=4.0.1, &lt;5</code> <code>4.0.12</code> BSD License GitPython GitPython is a Python library used to interact with Git repositories <code>3.1.44</code> BSD-3-Clause griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.49</code> <code>1.5.4</code> ISC htmlmin2 An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD idna Internationalized Domain Names in Applications (IDNA) <code>&gt;=2.5, &lt;4</code> <code>3.10</code> BSD License iniconfig brain-dead simple config-ini parsing <code>2.0.0</code> MIT jaraco.classes Utility functions for Python class constructs <code>3.4.0</code> MIT License jaraco.context Useful decorators and context managers <code>6.0.1</code> MIT License jaraco.functools Functools like those found in stdlib <code>4.1.0</code> MIT License jeepney Low-level, pure Python DBus protocol wrapper. <code>&gt;=0.4.2</code> <code>0.8.0</code> MIT License Jinja2 A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.5</code> BSD License jsmin JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License keyring Store and access your passwords safely. <code>&gt;=15.1</code> <code>25.6.0</code> MIT License Markdown Python implementation of John Gruber's Markdown. <code>&gt;=3.3.6</code> <code>3.7</code> BSD License markdown-callouts Markdown extension: a classier syntax for admonitions <code>&gt;=0.4</code> <code>0.4.0</code> MIT markdown-exec Utilities to execute code blocks in Markdown files. <code>&gt;=1.8</code> <code>1.10.0</code> ISC markdown-it-py Python port of markdown-it. Markdown parsing, done right! <code>&gt;=2.2.0</code> <code>3.0.0</code> MIT License MarkupSafe Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0.1</code> <code>3.0.2</code> BSD License mdurl Markdown URL utilities <code>~=0.1</code> <code>0.1.2</code> MIT License mergedeep A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License mkdocs Project documentation with Markdown. <code>&gt;=1.6</code> <code>1.6.1</code> BSD-2-Clause mkdocs-autorefs Automatically link across pages in MkDocs. <code>&gt;=1.2</code> <code>1.3.0</code> ISC mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=1.0</code> <code>1.1.0</code> ISC mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.5</code> <code>0.5.0</code> MIT mkdocs-get-deps MkDocs extension that lists all dependencies according to a mkdocs.yml file <code>&gt;=0.2.0</code> <code>0.2.0</code> MIT mkdocs-git-revision-date-localized-plugin Mkdocs plugin that enables displaying the localized date of the last git modification of a markdown file. <code>&gt;=1.2</code> <code>1.3.0</code> MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.6</code> <code>0.6.1</code> MIT mkdocs-material Documentation that simply works <code>&gt;=9.5</code> <code>9.5.49</code> MIT mkdocs-material-extensions Extension pack for Python Markdown and MkDocs Material. <code>~=1.3</code> <code>1.3.1</code> MIT mkdocs-minify-plugin An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;=0.8</code> <code>0.8.0</code> MIT mkdocstrings Automatic documentation from sources, for MkDocs. <code>&gt;=0.25</code> <code>0.27.0</code> ISC mkdocstrings-python A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.13.0</code> ISC more-itertools More routines for operating on iterables, beyond itertools <code>10.5.0</code> MIT License mypy Optional static typing for Python <code>&gt;=1.10</code> <code>1.14.1</code> MIT mypy-extensions Type system extensions for programs checked with the mypy type checker. <code>&gt;=1.0.0</code> <code>1.0.0</code> MIT License nh3 Python binding to Ammonia HTML sanitizer Rust crate <code>&gt;=0.2.14</code> <code>0.2.20</code> MIT packaging Core utilities for Python packages <code>&gt;=20.5</code> <code>24.2</code> Apache Software License + BSD License paginate Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.7</code> MIT pathspec Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.12.1</code> Mozilla Public License 2.0 (MPL 2.0) pkginfo Query metadata from sdists / bdists / installed packages. <code>&gt;=1.8.1</code> <code>1.12.0</code> MIT platformdirs A small Python package for determining appropriate platform-specific dirs, e.g. a <code>user data dir</code>. <code>&gt;=2</code> <code>4.3.6</code> MIT pluggy plugin and hook calling mechanisms for python <code>&gt;=1.5, &lt;2</code> <code>1.5.0</code> MIT ptyprocess Run a subprocess in a pseudo terminal <code>~=0.6</code> <code>0.7.0</code> ISC License (ISCL) pycparser C parser in Python <code>2.22</code> BSD-3-Clause Pygments Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.19.1</code> BSD-2-Clause pymdown-extensions Extension pack for Python Markdown. <code>~=10.2</code> <code>10.14</code> MIT pyproject_hooks Wrappers to call pyproject.toml-based build backend hooks. <code>1.2.0</code> MIT License pytest pytest: simple powerful testing with Python <code>&gt;=8.2</code> <code>8.3.4</code> MIT pytest-cov Pytest plugin for measuring coverage. <code>&gt;=5.0</code> <code>6.0.0</code> MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.15</code> <code>3.16.0</code> MIT License pytest-xdist pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=3.6</code> <code>3.6.1</code> MIT License python-dateutil Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.9.0.post0</code> BSD License + Apache Software License pytz World timezone definitions, modern and historical <code>2024.2</code> MIT PyYAML YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.2</code> MIT pyyaml_env_tag A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License readme_renderer readme_renderer is a library for rendering readme descriptions for Warehouse <code>&gt;=35.0</code> <code>44.0</code> Apache License, Version 2.0 regex Alternative regular expression module, to replace re. <code>&gt;=2022.4</code> <code>2024.11.6</code> Apache Software License requests Python HTTP for Humans. <code>&gt;=2.20</code> <code>2.32.3</code> Apache-2.0 requests-toolbelt A utility belt for advanced users of python-requests <code>&gt;=0.8.0, !=0.9.0</code> <code>1.0.0</code> Apache 2.0 rfc3986 Validating URI References per RFC 3986 <code>&gt;=1.4.0</code> <code>2.0.0</code> Apache 2.0 rich Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal <code>&gt;=12.0.0</code> <code>13.9.4</code> MIT ruff An extremely fast Python linter and code formatter, written in Rust. <code>&gt;=0.4</code> <code>0.9.1</code> MIT SecretStorage Python bindings to FreeDesktop.org Secret Service API <code>&gt;=3.2</code> <code>3.3.3</code> BSD 3-Clause License semver Python helper for Semantic Versioning (https://semver.org) <code>&gt;=2.13</code> <code>3.0.2</code> BSD six Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.17.0</code> MIT smmap A pure Python implementation of a sliding window memory map manager <code>&gt;=3.0.1, &lt;6</code> <code>5.0.2</code> BSD-3-Clause twine Collection of utilities for publishing packages on PyPI <code>&gt;=5.1</code> <code>6.0.1</code> Apache Software License types-Markdown Typing stubs for Markdown <code>&gt;=3.6</code> <code>3.7.0.20241204</code> Apache-2.0 types-PyYAML Typing stubs for PyYAML <code>&gt;=6.0</code> <code>6.0.12.20241230</code> Apache-2.0 typing_extensions Backported and Experimental Type Hints for Python 3.8+ <code>&gt;=4.6.0</code> <code>4.12.2</code> Python Software Foundation License urllib3 HTTP library with thread-safe connection pooling, file post, and more. <code>&gt;=1.26.0</code> <code>2.3.0</code> MIT License watchdog Filesystem events monitoring <code>&gt;=2.0</code> <code>6.0.0</code> Apache-2.0"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2018-2025 CSIRO\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"tech_notes/","title":"refcount tech notes","text":"<p>These are notes for the package maintainer(s). Most users can ignore them.</p>"},{"location":"tech_notes/#history","title":"History","text":"<ul> <li>Migrated to use poetry 2023-04 after reading https://py-pkgs.org, poetry grated but got over it. </li> <li>Jan 2025. poetry 2.0, Significant changes to the pyproject toml.</li> <li>installing poetry via pipx.</li> <li>BUT had started a branch for packaging with <code>uv</code>. Time to move on anyway.</li> <li>Trialing package development using this <code>copier-uv</code>template. Note also the blog post from Simon Wilson on uv</li> </ul>"},{"location":"tech_notes/#log","title":"log","text":"<pre><code># to update to the latest version\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nuv tool upgrade copier\ncd ~/src/pyrefcount\ncopier copy --trust \"gh:pawamoy/copier-uv\" .\ndirenv allow\n</code></pre> <p>Merging some changes manually for some overwritten files:</p> <pre><code>        modified:   .gitignore\n        modified:   CODE_OF_CONDUCT.md\n        modified:   CONTRIBUTING.md\n        modified:   README.md\n        modified:   docs/index.md\n        modified:   mkdocs.yml\n        modified:   pyproject.toml\n        modified:   tests/__init__.py\n</code></pre> <p>.envrc: </p> <pre><code>PATH_add scripts\nexport PYTHON_VERSIONS=\"3.12\"\n</code></pre> <pre><code>make setup\n\nmake check-quality\n</code></pre> <p>Lots of issues, but mostly e.g. single versus double quotes. In particular launch.json as it has some useful settings for native debugging.</p>"},{"location":"tech_notes/#ruff","title":"ruff","text":"<p>ruff setup. Back up files under .vscode just in case.</p> <p><code>make vscode</code>: \"To enable or disable Ruff after changing the <code>enable</code> setting, you must restart VS Code.\"</p> <p><code>uv run ruff check --fix</code></p> <p>it fixes only one error compared to 141 reported as fixable by <code>make check-quality</code>.</p> <p><code>uv run ruff check --config=config/ruff.toml --fix</code></p> <pre><code>Found 367 errors (148 fixed, 219 remaining).\nNo fixes available (99 hidden fixes can be enabled with the `--unsafe-fixes` option).\n</code></pre>"},{"location":"tech_notes/#manual-syntax-changes","title":"Manual syntax changes","text":"<pre><code>`typing.List` is deprecated, use `list` instead Ruff UP035\n</code></pre> <p>These are a bit of a bother. Type annotations, I think, encouraged e.g. the use of <code>List</code> instead of <code>list</code> years ago. This grates.</p>"},{"location":"tech_notes/#release-steps","title":"Release steps","text":"<ul> <li>all UT pass</li> <li>Merge new features/fixes to devel branch.</li> <li>version.py updated</li> <li>check readme is up to date</li> </ul> <pre><code>poetry install\npoetry version\npytest tests/\n</code></pre> <p>Not sure about using poetry for repos push.</p> <pre><code>poetry config repositories.test-pypi https://upload.pypi.org/legacy/\n</code></pre> <p>with <code>.pypirc</code> configured:</p> <pre><code>rm dist/*\npoetry build\nls dist/\n\ntwine upload -r testpypi dist/*\n# check\ntwine upload -r pypi dist/*\n</code></pre>"},{"location":"tech_notes/#code-deprecated","title":"Code - deprecated","text":"<pre><code>cd ~/src/github_jm/pyrefcount\n</code></pre> <pre><code>source ~/anaconda3/bin/activate\nmy_env_name=testpypirefcount\n</code></pre> <pre><code>conda create --name ${my_env_name} python=3.6\nconda activate ${my_env_name}\nconda install -c conda-forge wheel twine six pytest\n</code></pre> <pre><code>conda activate ${my_env_name}\ncd ~/src/github_jm/pyrefcount\nrm dist/*\npython setup.py sdist bdist_wheel\nrm dist/*.tar\n</code></pre> <p>Importantly to not end up with incorrect display of the readme:</p> <pre><code>twine check dist/*\n</code></pre> <pre><code>twine upload --repository-url https://test.pypi.org/legacy/ dist/*\n</code></pre> <p>Then and only then:</p> <pre><code>twine upload dist/*\n</code></pre>"},{"location":"tech_notes/#documentation","title":"Documentation","text":"<p>2021-01 Exploring options for putting this on readthedoc. I used in the past sphinx with napoleon extensions to document ela. This was a trial run. Did something more substantial for an internal project (WAA).</p> <p>Starting afresh with this, reading the RTD guides. Introduces mkdocs. Notice this blog on mkdocs-material which seems like the new cool kid on the block.</p> <p>Unclear from RTD where to create a new mkdocs project (supposed to be in the root of the python package?) not sure. for now:</p> <pre><code>cd doc\nmkdir mkd\ncd mkd/\nmkdocs new .\n</code></pre> <p><code>mamba install -c conda-forge mkdocs-material mkdocstrings</code> <code>mamba install -c conda-forge mkdocs-material-extensions</code></p> <p>Building the doc:</p> <pre><code>. ~/config/baseconda\nconda activate poetry\nmkdocs build --clean --site-dir _build/html --config-file mkdocs.yml\nmkdocs serve\n</code></pre>"},{"location":"tech_notes/#testing","title":"testing","text":"<pre><code># pytest tests/ --cov=refcounts # generates a warning about no coverage data cvollected\ncoverage run -m pytest\n# pytest --cov=refcounts --cov-report html\ncoverage report\ncoverage html -d coverage_html\n</code></pre>"},{"location":"tech_notes/#troubleshooting","title":"Troubleshooting","text":"<p>OUTDATED no more rst.</p> <pre><code>pandoc -f markdown -t rst README.md  &gt; README.rst\n</code></pre> <p>Can view with the <code>retext</code> program (did not find VScode RST extensions working, or giving out blank output if not, perhaps)</p> <pre><code>python setup.py check --restructuredtext\n</code></pre>"},{"location":"usage-and-applications/","title":"Usage and applications","text":""},{"location":"usage-and-applications/#overview","title":"Overview","text":"<p>In computer science, reference counting is a programming technique of storing the number of references, pointers, or handles to a resource, such as an object, a block of memory, disk space, and others.</p> <p>This <code>refcount</code> package is primarily for managing resources in native libraries, written for instance in C++, from Python. While it boils down to \"simply\" maintaining a set of counters, it is deceptively complicated to do so properly and not end up with memory leaks or crashes. This package offers structured options for reliably managing external native resources. Surprisingly I could not locate an existing python package doing just what I needed. Other use cases requiring reference counting, aside from native library resources, may benefit from reusing and extending classes in <code>refcount</code>.</p> <p>While <code>refcount</code> may be used in a variety of contexts, it evolved from use cases needing a Python wrapper around native libraries featuring a C API with opaque pointers (void*), using cffi for interoperability. This document will not list the many other ways this can be done, nor compare to them.</p>"},{"location":"usage-and-applications/#interfacing-with-a-c-api","title":"Interfacing with a C API","text":"<p><code>C</code> is still the \"lingua franca' of in-memory interoperability.</p> <p>Say we have a C++ library with objects and a C API. The example is contrived for the sake of simplicity.</p> <pre><code>#define TEST_DOG_PTR  testnative::dog*\n#define TEST_OWNER_PTR  testnative::owner*\n#define TEST_COUNTED_PTR  testnative::reference_counter*\n\ntestnative::dog* create_dog();\ntestnative::owner* create_owner(testnative::dog* d);\nvoid say_walk(testnative::owner* owner);\nvoid release(testnative::reference_counter* obj);\n// etc.\n</code></pre> <p>From the outside of the library the API is exported with opaque pointers <code>void*</code> (C structs pointers and native C99 types could be handled too).</p> <pre><code>void* create_dog();\nvoid* create_owner(void* d);\nvoid say_walk(void* owner);\nvoid release(void* obj);\n// etc.\n</code></pre> <p>A user experience in Python should be something like this:</p> <pre><code>dog = Dog()\nowner = DogOwner(dog)\nowner.say_walk()\nprint(dog.position)\ndog = None # the \"native dog\" is still alive though, as the owner incremented the ref count. Otherwise, we could have a dreaded segmentation fault.\nowner = None\n</code></pre> <p>We want python objects and functions hiding the low level details close to the C API, in particular the end user should avoiding managing native memory via <code>release</code> C API calls, piggybacking the python reference counting instead.</p>"},{"location":"usage-and-applications/#a-real-world-use-case","title":"A real-world use case","text":"<p>Let's look at a (hopefully) more compelling story. <code>refcount</code> is used to surface to Python a library to manage data for ensemble time series forecast simulation, uchronia. An example of such simulations is the 7-day Ensemble Streamflow Forecasts of the Australian Bureau of Meteorology.</p> <p>The header file for the C API of <code>uchronia</code> is in a file extern_c_api.h</p> <p>This C API has function definitions such as:</p> <pre><code>DATATYPES_API ENSEMBLE_DATA_SET_PTR LoadEnsembleDataset(const char* libraryIdentifier, const char* dataPath);\n</code></pre> <p>This uses some standard C types such as <code>char*</code>, but also an <code>ENSEMBLE_DATA_SET_PTR</code>, a pointer to a complex structure/object. Glossing over some details, this object is an instance of a C++ object <code>TimeSeriesLibrary</code>, actually of a C++ template class:</p> <pre><code>    template&lt;typename T&gt;\n    class TTimeSeriesLibrary\n</code></pre> <p>BUT <code>class</code> or <code>template</code> are not understood in <code>C</code>; from the outside of the library, this is just an opaque pointer <code>void*</code></p> <pre><code>void* LoadEnsembleDataset(const char* libraryIdentifier, const char* dataPath);\n</code></pre> <p>This is understandably all scary to most Python aficionados. We want to craft 'pythonic' user experience via first class python objects. An example of how it looks from the outside would be:</p> <pre><code>class TimeSeriesLibrary:\n    ###\n    def get_series_identifiers(self) -&gt; List['str']:\n        ## something magic calling the C API\n    def get_series(self, series_identifier:str) -&gt; pd.Series:\n        ## something magic calling the C API\n</code></pre>"},{"location":"usage-and-applications/#how-it-is-done","title":"How it is done","text":"<ul> <li>resource management: <code>refcount</code> is the cornerstone managing external resources (data in native memory), saving you from memory leaks or segmentation fault program crashes.</li> <li>data marshalling: The package <code>cinterop</code> offers facilities to convert data in C types (such as <code>double**</code>) into, for instance, an xarray DataArray or pandas DataFrame representation.</li> <li>code generation: Writing and maintening low-level interperability is tedious and bug prone. You'll want to automate and generate everything you can. One such generated code is uchronia_wrap_generated.py. Believe it or not, this is not a particularly large API, and code generation is already a must. This is achieved in this case with c-api-wrapper-generation</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> refcount<ul> <li> base</li> <li> debug</li> <li> interop</li> <li> putils</li> </ul> </li> </ul>"},{"location":"reference/refcount/","title":"refcount","text":""},{"location":"reference/refcount/#refcount","title":"refcount","text":"<p>refcount package.</p> <p>Python classes for reference counting</p> <p>Modules:</p> <ul> <li> <code>base</code>           \u2013            <p>Base classes for reference counting.</p> </li> <li> <code>debug</code>           \u2013            <p>Debugging utilities.</p> </li> <li> <code>interop</code>           \u2013            <p>Implementation of reference counting classes for external resources accessed via interoperability software such as cffi.</p> </li> <li> <code>putils</code>           \u2013            <p>Platform specific helpers to manage locating native dynamic libraries.</p> </li> </ul>"},{"location":"reference/refcount/base/","title":"refcount.base","text":""},{"location":"reference/refcount/base/#refcount.base","title":"base","text":"<p>Base classes for reference counting.</p> <p>Classes:</p> <ul> <li> <code>NativeHandle</code>           \u2013            <p>A base class for wrappers around otherwise \"unmanaged\" resources e.g. in a native library.</p> </li> <li> <code>ReferenceCounter</code>           \u2013            <p>A base class for reference counters.</p> </li> </ul>"},{"location":"reference/refcount/base/#refcount.base.NativeHandle","title":"NativeHandle","text":"<pre><code>NativeHandle(handle: Any = None, prior_ref_count: int = 0)\n</code></pre> <p>               Bases: <code>ReferenceCounter</code></p> <p>A base class for wrappers around otherwise \"unmanaged\" resources e.g. in a native library.</p> <p>Attributes:</p> <ul> <li> <code>_handle</code>               (<code>object</code>)           \u2013            <p>The handle (e.g. cffi pointer) to the native resource.</p> </li> <li> <code>_finalizing</code>               (<code>bool</code>)           \u2013            <p>a flag telling whether this object is in its deletion phase. This has a use in some advanced cases with reverse callback, possibly not relevant in Python.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>object</code>, default:                   <code>None</code> )           \u2013            <p>The handle (e.g. cffi pointer) to the native resource.</p> </li> <li> <code>prior_ref_count</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>the initial reference count. Default 0 if this NativeHandle is sole responsible for the lifecycle of the resource.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>decrement_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>reference_count</code>               (<code>int</code>)           \u2013            <p>Get the current reference count.</p> </li> </ul> Source code in <code>src/refcount/base.py</code> <pre><code>def __init__(self, handle: Any = None, prior_ref_count: int = 0):\n    \"\"\"Initialize a reference counter for a resource handle, with an initial reference count.\n\n    Args:\n        handle (object): The handle (e.g. cffi pointer) to the native resource.\n        prior_ref_count (int): the initial reference count. Default 0 if this NativeHandle is sole responsible for the lifecycle of the resource.\n    \"\"\"\n    super().__init__(prior_ref_count)\n    # TODO checks\n    self._finalizing: bool = False\n    self._handle: Any = None\n    if handle is None:\n        return  # defer setting handle to the inheritor.\n    self._set_handle(handle, prior_ref_count)\n</code></pre>"},{"location":"reference/refcount/base/#refcount.base.NativeHandle.reference_count","title":"reference_count  <code>property</code>","text":"<pre><code>reference_count: int\n</code></pre> <p>Get the current reference count.</p>"},{"location":"reference/refcount/base/#refcount.base.NativeHandle.add_ref","title":"add_ref","text":"<pre><code>add_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def add_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count + 1\n</code></pre>"},{"location":"reference/refcount/base/#refcount.base.NativeHandle.decrement_ref","title":"decrement_ref","text":"<pre><code>decrement_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def decrement_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count - 1\n</code></pre>"},{"location":"reference/refcount/base/#refcount.base.ReferenceCounter","title":"ReferenceCounter","text":"<pre><code>ReferenceCounter(prior_ref_count: int = 0)\n</code></pre> <p>A base class for reference counters.</p> <p>Attributes:</p> <ul> <li> <code>reference_count</code>               (<code>int</code>)           \u2013            <p>property getter, reference count</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>prior_ref_count</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>the initial reference count. Default 0 if this object is sole responsible for the lifecycle of the resource.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>decrement_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>reference_count</code>               (<code>int</code>)           \u2013            <p>Get the current reference count.</p> </li> </ul> Source code in <code>src/refcount/base.py</code> <pre><code>def __init__(self, prior_ref_count: int = 0):\n    \"\"\"Initialize this with an initial reference count.\n\n    Args:\n        prior_ref_count (int): the initial reference count. Default 0 if this object is sole responsible for the lifecycle of the resource.\n    \"\"\"\n    self._ref_count: int = prior_ref_count + 1\n</code></pre>"},{"location":"reference/refcount/base/#refcount.base.ReferenceCounter.reference_count","title":"reference_count  <code>property</code>","text":"<pre><code>reference_count: int\n</code></pre> <p>Get the current reference count.</p>"},{"location":"reference/refcount/base/#refcount.base.ReferenceCounter.add_ref","title":"add_ref","text":"<pre><code>add_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def add_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count + 1\n</code></pre>"},{"location":"reference/refcount/base/#refcount.base.ReferenceCounter.decrement_ref","title":"decrement_ref","text":"<pre><code>decrement_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def decrement_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count - 1\n</code></pre>"},{"location":"reference/refcount/debug/","title":"refcount.debug","text":""},{"location":"reference/refcount/debug/#refcount.debug","title":"debug","text":"<p>Debugging utilities.</p> <p>Classes:</p> <ul> <li> <code>Environment</code>           \u2013            <p>Dataclass to store environment information.</p> </li> <li> <code>Package</code>           \u2013            <p>Dataclass describing a Python package.</p> </li> <li> <code>Variable</code>           \u2013            <p>Dataclass describing an environment variable.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_debug_info</code>             \u2013              <p>Get debug/environment information.</p> </li> <li> <code>get_version</code>             \u2013              <p>Get version of the given distribution.</p> </li> <li> <code>print_debug_info</code>             \u2013              <p>Print debug/environment information.</p> </li> </ul>"},{"location":"reference/refcount/debug/#refcount.debug.Environment","title":"Environment  <code>dataclass</code>","text":"<pre><code>Environment(\n    interpreter_name: str,\n    interpreter_version: str,\n    interpreter_path: str,\n    platform: str,\n    packages: list[Package],\n    variables: list[Variable],\n)\n</code></pre> <p>Dataclass to store environment information.</p> <p>Attributes:</p> <ul> <li> <code>interpreter_name</code>               (<code>str</code>)           \u2013            <p>Python interpreter name.</p> </li> <li> <code>interpreter_path</code>               (<code>str</code>)           \u2013            <p>Path to Python executable.</p> </li> <li> <code>interpreter_version</code>               (<code>str</code>)           \u2013            <p>Python interpreter version.</p> </li> <li> <code>packages</code>               (<code>list[Package]</code>)           \u2013            <p>Installed packages.</p> </li> <li> <code>platform</code>               (<code>str</code>)           \u2013            <p>Operating System.</p> </li> <li> <code>variables</code>               (<code>list[Variable]</code>)           \u2013            <p>Environment variables.</p> </li> </ul>"},{"location":"reference/refcount/debug/#refcount.debug.Environment.interpreter_name","title":"interpreter_name  <code>instance-attribute</code>","text":"<pre><code>interpreter_name: str\n</code></pre> <p>Python interpreter name.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Environment.interpreter_path","title":"interpreter_path  <code>instance-attribute</code>","text":"<pre><code>interpreter_path: str\n</code></pre> <p>Path to Python executable.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Environment.interpreter_version","title":"interpreter_version  <code>instance-attribute</code>","text":"<pre><code>interpreter_version: str\n</code></pre> <p>Python interpreter version.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Environment.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages: list[Package]\n</code></pre> <p>Installed packages.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Environment.platform","title":"platform  <code>instance-attribute</code>","text":"<pre><code>platform: str\n</code></pre> <p>Operating System.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Environment.variables","title":"variables  <code>instance-attribute</code>","text":"<pre><code>variables: list[Variable]\n</code></pre> <p>Environment variables.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Package","title":"Package  <code>dataclass</code>","text":"<pre><code>Package(name: str, version: str)\n</code></pre> <p>Dataclass describing a Python package.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Package name.</p> </li> <li> <code>version</code>               (<code>str</code>)           \u2013            <p>Package version.</p> </li> </ul>"},{"location":"reference/refcount/debug/#refcount.debug.Package.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Package name.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Package.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Package version.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Variable","title":"Variable  <code>dataclass</code>","text":"<pre><code>Variable(name: str, value: str)\n</code></pre> <p>Dataclass describing an environment variable.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Variable name.</p> </li> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>Variable value.</p> </li> </ul>"},{"location":"reference/refcount/debug/#refcount.debug.Variable.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Variable name.</p>"},{"location":"reference/refcount/debug/#refcount.debug.Variable.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str\n</code></pre> <p>Variable value.</p>"},{"location":"reference/refcount/debug/#refcount.debug.get_debug_info","title":"get_debug_info","text":"<pre><code>get_debug_info() -&gt; Environment\n</code></pre> <p>Get debug/environment information.</p> <p>Returns:</p> <ul> <li> <code>Environment</code>           \u2013            <p>Environment information.</p> </li> </ul> Source code in <code>src/refcount/debug.py</code> <pre><code>def get_debug_info() -&gt; Environment:\n    \"\"\"Get debug/environment information.\n\n    Returns:\n        Environment information.\n    \"\"\"\n    py_name, py_version = _interpreter_name_version()\n    packages = [\"refcount\"]\n    variables = [\"PYTHONPATH\", *[var for var in os.environ if var.startswith(\"REFCOUNT\")]]\n    return Environment(\n        interpreter_name=py_name,\n        interpreter_version=py_version,\n        interpreter_path=sys.executable,\n        platform=platform.platform(),\n        variables=[Variable(var, val) for var in variables if (val := os.getenv(var))],\n        packages=[Package(pkg, get_version(pkg)) for pkg in packages],\n    )\n</code></pre>"},{"location":"reference/refcount/debug/#refcount.debug.get_version","title":"get_version","text":"<pre><code>get_version(dist: str = 'refcount') -&gt; str\n</code></pre> <p>Get version of the given distribution.</p> <p>Parameters:</p> <ul> <li> <code>dist</code>               (<code>str</code>, default:                   <code>'refcount'</code> )           \u2013            <p>A distribution name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A version number.</p> </li> </ul> Source code in <code>src/refcount/debug.py</code> <pre><code>def get_version(dist: str = \"refcount\") -&gt; str:\n    \"\"\"Get version of the given distribution.\n\n    Parameters:\n        dist: A distribution name.\n\n    Returns:\n        A version number.\n    \"\"\"\n    try:\n        return metadata.version(dist)\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/refcount/debug/#refcount.debug.print_debug_info","title":"print_debug_info","text":"<pre><code>print_debug_info() -&gt; None\n</code></pre> <p>Print debug/environment information.</p> Source code in <code>src/refcount/debug.py</code> <pre><code>def print_debug_info() -&gt; None:\n    \"\"\"Print debug/environment information.\"\"\"\n    info = get_debug_info()\n    print(f\"- __System__: {info.platform}\")\n    print(f\"- __Python__: {info.interpreter_name} {info.interpreter_version} ({info.interpreter_path})\")\n    print(\"- __Environment variables__:\")\n    for var in info.variables:\n        print(f\"  - `{var.name}`: `{var.value}`\")\n    print(\"- __Installed packages__:\")\n    for pkg in info.packages:\n        print(f\"  - `{pkg.name}` v{pkg.version}\")\n</code></pre>"},{"location":"reference/refcount/interop/","title":"refcount.interop","text":""},{"location":"reference/refcount/interop/#refcount.interop","title":"interop","text":"<p>Implementation of reference counting classes for external resources accessed via interoperability software such as cffi.</p> <p>Classes:</p> <ul> <li> <code>CffiNativeHandle</code>           \u2013            <p>Reference counting wrapper class for CFFI pointers.</p> </li> <li> <code>CffiWrapperFactory</code>           \u2013            <p>A class that creates custom python wrappers based on the type identifier of the external pointer being wrapped.</p> </li> <li> <code>DeletableCffiNativeHandle</code>           \u2013            <p>Reference counting wrapper class for CFFI pointers.</p> </li> <li> <code>GenericWrapper</code>           \u2013            <p>A pass-through wrapper for python objects that are ready for C interop. \"bytes\" can be passed as C 'char*'.</p> </li> <li> <code>OwningCffiNativeHandle</code>           \u2013            <p>Reference counting wrapper class for CFFI pointers that own and already manage the native memory.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>cffi_arg_error_external_obj_type</code>             \u2013              <p>Build an error message that an unexpected object is in lieu of an expected refcount external ref object.</p> </li> <li> <code>is_cffi_native_handle</code>             \u2013              <p>Checks whether an object is a ref counting wrapper around a CFFI pointer.</p> </li> <li> <code>type_error_cffi</code>             \u2013              <p>DEPRECATED.</p> </li> <li> <code>unwrap_cffi_native_handle</code>             \u2013              <p>Unwrap a reference counting wrapper and returns its CFFI pointer if it is found (wrapped or 'raw').</p> </li> <li> <code>wrap_as_pointer_handle</code>             \u2013              <p>Wrap an object, if need be, so that its C API pointer appears accessible via a 'ptr' property.</p> </li> <li> <code>wrap_cffi_native_handle</code>             \u2013              <p>Create a reference counting wrapper around an object if this object is a CFFI pointer.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>CffiData</code>               (<code>TypeAlias</code>)           \u2013            <p>A dummy type to use in type hints for limited documentation purposes</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.CffiData","title":"CffiData  <code>module-attribute</code>","text":"<pre><code>CffiData: TypeAlias = Any\n</code></pre> <p>A dummy type to use in type hints for limited documentation purposes</p> <p>FFI.CData is a type, but it seems it cannot be used in type hinting.</p>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle","title":"CffiNativeHandle","text":"<pre><code>CffiNativeHandle(\n    handle: CffiData,\n    type_id: Optional[str] = None,\n    prior_ref_count: int = 0,\n)\n</code></pre> <p>               Bases: <code>NativeHandle</code></p> <p>Reference counting wrapper class for CFFI pointers.</p> <p>This class is originally inspired from a class with a similar purpose in C#. See https://github.com/rdotnet/dynamic-interop-dll</p> <p>Say you have a C API as follows:</p> <ul> <li><code>void* create_some_object();</code></li> <li><code>dispose_of_some_object(void* obj);</code></li> </ul> <p>and accessing it using Python and CFFI. Users would use the <code>calllib</code> function:</p> <pre><code>from cffi import FFI\n\nffi = FFI()\n\n# cdef() expects a single string declaring the C types, functions and\n# globals needed to use the shared object. It must be in valid C syntax.\nffi.cdef('''\n    void* create_some_object();\n    dispose_of_some_object(void* obj);\n''')\nmydll_so = ffi.dlopen(\"/path/to/mydll.so\", ffi.RTLD_LAZY)\ncffi_void_ptr = mydll_so.create_some_object()\n</code></pre> <p>at some point when done you need to dispose of it to clear native memory:</p> <pre><code>mydll_so.dispose_of_some_object(cffi_void_ptr)\n</code></pre> <p>In practice in real systems one quickly ends up with cases where it is unclear when to dispose of the object. If you call the <code>dispose_of_some_object</code> function more than once, or too soon, you quickly crash the program, or possibly worse outcomes with numeric non-sense. <code>CffiNativeHandle</code> is designed to alleviate this headache by using native reference counting of <code>handle</code> classes to reliably dispose of objects.</p> <p>Attributes:</p> <ul> <li> <code>_handle</code>               (<code>object</code>)           \u2013            <p>The handle (e.g. cffi pointer) to the native resource.</p> </li> <li> <code>_type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.</p> </li> <li> <code>_finalizing</code>               (<code>bool</code>)           \u2013            <p>a flag telling whether this object is in its deletion phase. This has a use in some advanced cases with reverse callback, possibly not relevant in Python.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>object</code>)           \u2013            <p>The handle (e.g. cffi pointer) to the native resource.</p> </li> <li> <code>type_id</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.</p> </li> <li> <code>prior_ref_count</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>the initial reference count. Default 0 if this NativeHandle is sole responsible for the lifecycle of the resource.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>decrement_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>dispose</code>             \u2013              <p>Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.</p> </li> <li> <code>get_handle</code>             \u2013              <p>Gets the underlying low-level CFFI handle this object wraps.</p> </li> <li> <code>release</code>             \u2013              <p>Manually decrements the reference counter. Triggers disposal if reference count is down to zero.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>disposed</code>               (<code>bool</code>)           \u2013            <p>Has the native object and memory already been disposed of.</p> </li> <li> <code>is_invalid</code>               (<code>bool</code>)           \u2013            <p>Is the underlying handle valid? In practice synonym with the disposed attribute.</p> </li> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>Return the object pointed to (cffi object).</p> </li> <li> <code>ptr</code>               (<code>CffiData</code>)           \u2013            <p>Return the pointer (cffi object).</p> </li> <li> <code>reference_count</code>               (<code>int</code>)           \u2013            <p>Get the current reference count.</p> </li> <li> <code>type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Return an optional type identifier for the underlying native type.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def __init__(self, handle: \"CffiData\", type_id: Optional[str] = None, prior_ref_count: int = 0):\n    \"\"\"Initialize a reference counter for a resource handle, with an initial reference count.\n\n    Args:\n        handle (object): The handle (e.g. cffi pointer) to the native resource.\n        type_id (Optional[str]): An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.\n        prior_ref_count (int): the initial reference count. Default 0 if this NativeHandle is sole responsible for the lifecycle of the resource.\n    \"\"\"\n    super().__init__(handle, prior_ref_count)\n    # TODO checks on handle\n    self._type_id = type_id\n    self._finalizing: bool = False\n    self._handle: CffiData = None\n    if handle is None:\n        return  # defer setting the handle to the inheritor.\n    self._set_handle(handle, prior_ref_count)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.disposed","title":"disposed  <code>property</code>","text":"<pre><code>disposed: bool\n</code></pre> <p>Has the native object and memory already been disposed of.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>The underlying native handle has been disposed of from this wrapper</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.is_invalid","title":"is_invalid  <code>property</code>","text":"<pre><code>is_invalid: bool\n</code></pre> <p>Is the underlying handle valid? In practice synonym with the disposed attribute.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this handle is valid</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.obj","title":"obj  <code>property</code>","text":"<pre><code>obj: Any\n</code></pre> <p>Return the object pointed to (cffi object).</p>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.ptr","title":"ptr  <code>property</code>","text":"<pre><code>ptr: CffiData\n</code></pre> <p>Return the pointer (cffi object).</p>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.reference_count","title":"reference_count  <code>property</code>","text":"<pre><code>reference_count: int\n</code></pre> <p>Get the current reference count.</p>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.type_id","title":"type_id  <code>property</code>","text":"<pre><code>type_id: Optional[str]\n</code></pre> <p>Return an optional type identifier for the underlying native type.</p> <p>This can be in practice useful to be more transparent about the underlying type obtained via a C API with opaque pointers (i.e. void*)</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>Optional[str]</code> )          \u2013            <p>optional type identifier</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.add_ref","title":"add_ref","text":"<pre><code>add_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def add_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count + 1\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.decrement_ref","title":"decrement_ref","text":"<pre><code>decrement_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def decrement_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count - 1\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.dispose","title":"dispose","text":"<pre><code>dispose() -&gt; None\n</code></pre> <p>Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.</p> Source code in <code>src/refcount/interop.py</code> <pre><code>def dispose(self) -&gt; None:\n    \"\"\"Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.\"\"\"\n    self.__dispose_impl(True)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.get_handle","title":"get_handle","text":"<pre><code>get_handle() -&gt; Union[CffiData, None]\n</code></pre> <p>Gets the underlying low-level CFFI handle this object wraps.</p> <p>Returns:</p> <ul> <li> <code>Union[CffiData, None]</code>           \u2013            <p>CFFI handle or None</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def get_handle(self) -&gt; Union[\"CffiData\", None]:\n    \"\"\"Gets the underlying low-level CFFI handle this object wraps.\n\n    Returns:\n        (Union[CffiData, None]): CFFI handle or None\n    \"\"\"\n    return self._handle\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.CffiNativeHandle.release","title":"release","text":"<pre><code>release() -&gt; None\n</code></pre> <p>Manually decrements the reference counter. Triggers disposal if reference count is down to zero.</p> Source code in <code>src/refcount/interop.py</code> <pre><code>def release(self) -&gt; None:\n    \"\"\"Manually decrements the reference counter. Triggers disposal if reference count is down to zero.\"\"\"\n    self.__dispose_impl(True)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.CffiWrapperFactory","title":"CffiWrapperFactory","text":"<pre><code>CffiWrapperFactory(\n    api_type_wrapper: Dict[str, Any],\n    strict_wrapping: bool = False,\n)\n</code></pre> <p>A class that creates custom python wrappers based on the type identifier of the external pointer being wrapped.</p> <p>Parameters:</p> <ul> <li> <code>api_type_wrapper</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>dictionary, mapping from type identifiers to callables, class constructors</p> </li> <li> <code>strict_wrapping</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, type identifiers passed at wrapper creation time <code>create_wrapper</code> must be known or exceptions are raised. If False, it falls back on creating generic wrappers. Defaults to False.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>create_wrapper</code>             \u2013              <p>Create a CffiNativeHandle wrapper around an object, if this object is a CFFI pointer.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def __init__(self, api_type_wrapper: Dict[str, Any], strict_wrapping: bool = False) -&gt; None:\n    \"\"\"A class that creates custom python wrappers based on the type identifier of the external pointer being wrapped.\n\n    Args:\n        api_type_wrapper (Dict[str,Any]): dictionary, mapping from type identifiers to callables, class constructors\n        strict_wrapping (bool, optional): If true, type identifiers passed at wrapper creation time `create_wrapper`\n            must be known or exceptions are raised. If False, it falls back on creating generic wrappers. Defaults to False.\n    \"\"\"\n    self._strict_wrapping = strict_wrapping\n    self._api_type_wrapper = api_type_wrapper\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.CffiWrapperFactory.create_wrapper","title":"create_wrapper","text":"<pre><code>create_wrapper(\n    obj: Any,\n    type_id: str,\n    release_native: Optional[Callable[[CffiData], None]],\n) -&gt; CffiNativeHandle\n</code></pre> <p>Create a CffiNativeHandle wrapper around an object, if this object is a CFFI pointer.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Union[CffiData, Any]</code>)           \u2013            <p>An object, which will be wrapped if this is a CFFI pointer, i.e. an instance of <code>CffiData</code></p> </li> <li> <code>type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.</p> </li> <li> <code>release_native</code>               (<code>Callable[[CffiData], None]</code>)           \u2013            <p>function to call on deleting this wrapper. The function should have one argument accepting the object handle.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Missing type_id</p> </li> <li> <code>ValueError</code>             \u2013            <p>If this object is in strict mode, and <code>type_id</code> is not known in the mapping</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p><code>type_id</code> is known, but mapping to None (wrapper not yet implemented)</p> </li> <li> <code>TypeError</code>             \u2013            <p>The function to create the wrapper does not accept any argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CffiNativeHandle</code> (              <code>CffiNativeHandle</code> )          \u2013            <p>cffi wrapper</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def create_wrapper(\n    self,\n    obj: Any,\n    type_id: str,\n    release_native: Optional[Callable[[\"CffiData\"], None]],\n) -&gt; \"CffiNativeHandle\":\n    \"\"\"Create a CffiNativeHandle wrapper around an object, if this object is a CFFI pointer.\n\n    Args:\n        obj (Union[CffiData,Any]): An object, which will be wrapped if this is a CFFI pointer, i.e. an instance of `CffiData`\n        type_id (Optional[str]): An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.\n        release_native (Callable[[CffiData],None]): function to call on deleting this wrapper. The function should have one argument accepting the object handle.\n\n    Raises:\n        ValueError: Missing type_id\n        ValueError: If this object is in strict mode, and `type_id` is not known in the mapping\n        NotImplementedError: `type_id` is known, but mapping to None (wrapper not yet implemented)\n        TypeError: The function to create the wrapper does not accept any argument.\n\n    Returns:\n        CffiNativeHandle: cffi wrapper\n    \"\"\"\n    from inspect import signature\n\n    # from typing import get_type_hints\n    if type_id is None:\n        raise ValueError(\"Type ID provided cannot be None\")\n    if type_id not in self._api_type_wrapper:\n        if self._strict_wrapping:\n            raise ValueError(f\"Type ID {type_id} is unknown\")\n        return wrap_cffi_native_handle(obj, type_id, release_native)\n    wrapper_type = self._api_type_wrapper[type_id]\n    if wrapper_type is None:\n        if self._strict_wrapping:\n            raise NotImplementedError(\n                f\"Python object wrapper for foreign type ID {wrapper_type} is not yet implemented\",\n            )\n        return wrap_cffi_native_handle(obj, type_id, release_native)\n    s = signature(wrapper_type)\n    n = len(s.parameters)\n    parameters = [v for k, v in s.parameters.items()]\n    # [&lt;Parameter \"handle: Any\"&gt;, &lt;Parameter \"release_native: Callable[[Any], NoneType]\"&gt;, &lt;Parameter \"type_id: Optional[str] = None\"&gt;, &lt;Parameter \"prior_ref_count: int = 0\"&gt;]\n    if n == 0:\n        raise TypeError(\n            f\"Wrapper class '{wrapper_type.__name__}' has no constructor arguments; at least one is required\",\n        )\n    if n == 1:\n        return wrapper_type(obj)\n    if n == 2:  # noqa: PLR2004\n        if release_native is None:\n            raise ValueError(\n                f\"Wrapper class '{wrapper_type.__name__}' has two constructor arguments; the argument 'release_native' cannot be None\",\n            )\n        return wrapper_type(obj, release_native)\n    if n == 3:  # noqa: PLR2004\n        if release_native is None:\n            raise ValueError(\n                f\"Wrapper class '{type(wrapper_type)}' has three constructor arguments; the argument 'release_native' cannot be None\",\n            )\n        return wrapper_type(obj, release_native, type_id)\n    if n == 4:  # noqa: PLR2004\n        p = parameters[3]\n        # constructor = wrapper_type.__init__\n        # type_hints = get_type_hints(constructor)\n        param_type = p.annotation\n        if param_type is not int:\n            raise TypeError(\n                f\"Wrapper class '{type(wrapper_type)}' has four constructor arguments; the last argument 'prior_ref_count' must be an integer\",\n            )\n        if parameters[3].default == parameters[3].empty:\n            raise ValueError(\n                f\"Wrapper class '{type(wrapper_type)}' has four constructor arguments; the last argument 'prior_ref_count' must have a default value\",\n            )\n        return wrapper_type(obj, release_native, type_id)\n    raise NotImplementedError(\n        f\"Wrapper class '{wrapper_type.__name__}' has more than 4 arguments; this is not supported\",\n    )\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle","title":"DeletableCffiNativeHandle","text":"<pre><code>DeletableCffiNativeHandle(\n    handle: CffiData,\n    release_native: Optional[Callable[[CffiData], None]],\n    type_id: Optional[str] = None,\n    prior_ref_count: int = 0,\n)\n</code></pre> <p>               Bases: <code>CffiNativeHandle</code></p> <p>Reference counting wrapper class for CFFI pointers.</p> <p>Attributes:</p> <ul> <li> <code>_handle</code>               (<code>object</code>)           \u2013            <p>The handle (e.g. cffi pointer) to the native resource.</p> </li> <li> <code>_type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.</p> </li> <li> <code>_finalizing</code>               (<code>bool</code>)           \u2013            <p>a flag telling whether this object is in its deletion phase. This has a use in some advanced cases with reverse callback, possibly not relevant in Python.</p> </li> <li> <code>_release_native</code>               (<code>Callable[[CffiData], None]</code>)           \u2013            <p>function to call on deleting this wrapper. The function should have one argument accepting the object _handle.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>CffiData</code>)           \u2013            <p>The handle (expected cffi pointer) to the native resource.</p> </li> <li> <code>release_native</code>               (<code>Callable[[CffiData], None]</code>)           \u2013            <p>function to call on deleting this wrapper. The function should have one argument accepting the object handle.</p> </li> <li> <code>type_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>[description]. An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation. Defaults to None.</p> </li> <li> <code>prior_ref_count</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>[description]. The initial reference count. Defaults to 0 if this NativeHandle is sole responsible for the lifecycle of the resource.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>decrement_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>dispose</code>             \u2013              <p>Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.</p> </li> <li> <code>get_handle</code>             \u2013              <p>Gets the underlying low-level CFFI handle this object wraps.</p> </li> <li> <code>release</code>             \u2013              <p>Manually decrements the reference counter. Triggers disposal if reference count is down to zero.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>disposed</code>               (<code>bool</code>)           \u2013            <p>Has the native object and memory already been disposed of.</p> </li> <li> <code>is_invalid</code>               (<code>bool</code>)           \u2013            <p>Is the underlying handle valid? In practice synonym with the disposed attribute.</p> </li> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>Return the object pointed to (cffi object).</p> </li> <li> <code>ptr</code>               (<code>CffiData</code>)           \u2013            <p>Return the pointer (cffi object).</p> </li> <li> <code>reference_count</code>               (<code>int</code>)           \u2013            <p>Get the current reference count.</p> </li> <li> <code>type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Return an optional type identifier for the underlying native type.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def __init__(\n    self,\n    handle: \"CffiData\",\n    release_native: Optional[Callable[[\"CffiData\"], None]],\n    type_id: Optional[str] = None,\n    prior_ref_count: int = 0,\n):\n    \"\"\"New reference counter for a CFFI resource handle.\n\n    Args:\n        handle (CffiData): The handle (expected cffi pointer) to the native resource.\n        release_native (Callable[[CffiData],None]): function to call on deleting this wrapper. The function should have one argument accepting the object handle.\n        type_id (str, optional): [description]. An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation. Defaults to None.\n        prior_ref_count (int, optional): [description]. The initial reference count. Defaults to 0 if this NativeHandle is sole responsible for the lifecycle of the resource.\n    \"\"\"\n    super().__init__(\n        handle,\n        type_id,\n        prior_ref_count,\n    )\n    self._release_native = release_native\n    self._set_handle(handle, prior_ref_count)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.disposed","title":"disposed  <code>property</code>","text":"<pre><code>disposed: bool\n</code></pre> <p>Has the native object and memory already been disposed of.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>The underlying native handle has been disposed of from this wrapper</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.is_invalid","title":"is_invalid  <code>property</code>","text":"<pre><code>is_invalid: bool\n</code></pre> <p>Is the underlying handle valid? In practice synonym with the disposed attribute.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this handle is valid</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.obj","title":"obj  <code>property</code>","text":"<pre><code>obj: Any\n</code></pre> <p>Return the object pointed to (cffi object).</p>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.ptr","title":"ptr  <code>property</code>","text":"<pre><code>ptr: CffiData\n</code></pre> <p>Return the pointer (cffi object).</p>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.reference_count","title":"reference_count  <code>property</code>","text":"<pre><code>reference_count: int\n</code></pre> <p>Get the current reference count.</p>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.type_id","title":"type_id  <code>property</code>","text":"<pre><code>type_id: Optional[str]\n</code></pre> <p>Return an optional type identifier for the underlying native type.</p> <p>This can be in practice useful to be more transparent about the underlying type obtained via a C API with opaque pointers (i.e. void*)</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>Optional[str]</code> )          \u2013            <p>optional type identifier</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.add_ref","title":"add_ref","text":"<pre><code>add_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def add_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count + 1\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.decrement_ref","title":"decrement_ref","text":"<pre><code>decrement_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def decrement_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count - 1\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.dispose","title":"dispose","text":"<pre><code>dispose() -&gt; None\n</code></pre> <p>Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.</p> Source code in <code>src/refcount/interop.py</code> <pre><code>def dispose(self) -&gt; None:\n    \"\"\"Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.\"\"\"\n    self.__dispose_impl(True)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.get_handle","title":"get_handle","text":"<pre><code>get_handle() -&gt; Union[CffiData, None]\n</code></pre> <p>Gets the underlying low-level CFFI handle this object wraps.</p> <p>Returns:</p> <ul> <li> <code>Union[CffiData, None]</code>           \u2013            <p>CFFI handle or None</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def get_handle(self) -&gt; Union[\"CffiData\", None]:\n    \"\"\"Gets the underlying low-level CFFI handle this object wraps.\n\n    Returns:\n        (Union[CffiData, None]): CFFI handle or None\n    \"\"\"\n    return self._handle\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.DeletableCffiNativeHandle.release","title":"release","text":"<pre><code>release() -&gt; None\n</code></pre> <p>Manually decrements the reference counter. Triggers disposal if reference count is down to zero.</p> Source code in <code>src/refcount/interop.py</code> <pre><code>def release(self) -&gt; None:\n    \"\"\"Manually decrements the reference counter. Triggers disposal if reference count is down to zero.\"\"\"\n    self.__dispose_impl(True)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.GenericWrapper","title":"GenericWrapper","text":"<pre><code>GenericWrapper(handle: CffiData)\n</code></pre> <p>A pass-through wrapper for python objects that are ready for C interop. \"bytes\" can be passed as C 'char*'.</p> <p>This is mostly a facility to generate glue code more easily</p> <p>Attributes:</p> <ul> <li> <code>ptr</code>               (<code>CffiData</code>)           \u2013            <p>The wrapped python object that is ready for C interop.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def __init__(self, handle: \"CffiData\"):\n    \"\"\"A pass-through wrapper for python objects that are ready for C interop. \"bytes\" can be passed as C 'char*'.\"\"\"\n    self._handle = handle\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.GenericWrapper.ptr","title":"ptr  <code>property</code>","text":"<pre><code>ptr: CffiData\n</code></pre> <p>The wrapped python object that is ready for C interop.</p>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle","title":"OwningCffiNativeHandle","text":"<pre><code>OwningCffiNativeHandle(\n    handle: CffiData,\n    type_id: Optional[str] = None,\n    prior_ref_count: int = 0,\n)\n</code></pre> <p>               Bases: <code>CffiNativeHandle</code></p> <p>Reference counting wrapper class for CFFI pointers that own and already manage the native memory.</p> <p>Attributes:</p> <ul> <li> <code>_handle</code>               (<code>object</code>)           \u2013            <p>The handle (e.g. cffi pointer) to the native resource.</p> </li> <li> <code>_type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.</p> </li> <li> <code>_finalizing</code>               (<code>bool</code>)           \u2013            <p>a flag telling whether this object is in its deletion phase. This has a use in some advanced cases with reverse callback, possibly not relevant in Python.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>handle</code>               (<code>CffiData</code>)           \u2013            <p>The handle (expected cffi pointer) to the native resource.</p> </li> <li> <code>type_id</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>[description]. An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation. Defaults to None.</p> </li> <li> <code>prior_ref_count</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>[description]. The initial reference count. Defaults to 0 if this NativeHandle is sole responsible for the lifecycle of the resource.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>decrement_ref</code>             \u2013              <p>Manually increment the reference count.</p> </li> <li> <code>dispose</code>             \u2013              <p>Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.</p> </li> <li> <code>get_handle</code>             \u2013              <p>Gets the underlying low-level CFFI handle this object wraps.</p> </li> <li> <code>release</code>             \u2013              <p>Manually decrements the reference counter. Triggers disposal if reference count is down to zero.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>disposed</code>               (<code>bool</code>)           \u2013            <p>Has the native object and memory already been disposed of.</p> </li> <li> <code>is_invalid</code>               (<code>bool</code>)           \u2013            <p>Is the underlying handle valid? In practice synonym with the disposed attribute.</p> </li> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>Return the object pointed to (cffi object).</p> </li> <li> <code>ptr</code>               (<code>CffiData</code>)           \u2013            <p>Return the pointer (cffi object).</p> </li> <li> <code>reference_count</code>               (<code>int</code>)           \u2013            <p>Get the current reference count.</p> </li> <li> <code>type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Return an optional type identifier for the underlying native type.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def __init__(\n    self,\n    handle: \"CffiData\",\n    type_id: Optional[str] = None,\n    prior_ref_count: int = 0,\n):\n    \"\"\"Reference counting wrapper class for CFFI pointers that own and already manage the native memory.\n\n    Args:\n        handle (CffiData): The handle (expected cffi pointer) to the native resource.\n        type_id (str, optional): [description]. An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation. Defaults to None.\n        prior_ref_count (int, optional): [description]. The initial reference count. Defaults to 0 if this NativeHandle is sole responsible for the lifecycle of the resource.\n    \"\"\"\n    super().__init__(\n        handle,\n        type_id,\n        prior_ref_count,\n    )\n    self._set_handle(handle, prior_ref_count)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.disposed","title":"disposed  <code>property</code>","text":"<pre><code>disposed: bool\n</code></pre> <p>Has the native object and memory already been disposed of.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>The underlying native handle has been disposed of from this wrapper</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.is_invalid","title":"is_invalid  <code>property</code>","text":"<pre><code>is_invalid: bool\n</code></pre> <p>Is the underlying handle valid? In practice synonym with the disposed attribute.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this handle is valid</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.obj","title":"obj  <code>property</code>","text":"<pre><code>obj: Any\n</code></pre> <p>Return the object pointed to (cffi object).</p>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.ptr","title":"ptr  <code>property</code>","text":"<pre><code>ptr: CffiData\n</code></pre> <p>Return the pointer (cffi object).</p>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.reference_count","title":"reference_count  <code>property</code>","text":"<pre><code>reference_count: int\n</code></pre> <p>Get the current reference count.</p>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.type_id","title":"type_id  <code>property</code>","text":"<pre><code>type_id: Optional[str]\n</code></pre> <p>Return an optional type identifier for the underlying native type.</p> <p>This can be in practice useful to be more transparent about the underlying type obtained via a C API with opaque pointers (i.e. void*)</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>Optional[str]</code> )          \u2013            <p>optional type identifier</p> </li> </ul>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.add_ref","title":"add_ref","text":"<pre><code>add_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def add_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count + 1\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.decrement_ref","title":"decrement_ref","text":"<pre><code>decrement_ref() -&gt; None\n</code></pre> <p>Manually increment the reference count.</p> <p>Users usually have no need to call this method. They may have to if they manage cases where one native handle wrapper uses another wrapper (and its underlying resource).</p> Source code in <code>src/refcount/base.py</code> <pre><code>def decrement_ref(self) -&gt; None:\n    \"\"\"Manually increment the reference count.\n\n    Users usually have no need to call this method. They may have to if they\n    manage cases where one native handle wrapper uses another wrapper (and its underlying resource).\n    \"\"\"\n    self._ref_count = self._ref_count - 1\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.dispose","title":"dispose","text":"<pre><code>dispose() -&gt; None\n</code></pre> <p>Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.</p> Source code in <code>src/refcount/interop.py</code> <pre><code>def dispose(self) -&gt; None:\n    \"\"\"Disposing of the object pointed to by the CFFI pointer (handle) if the reference counts allows it.\"\"\"\n    self.__dispose_impl(True)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.get_handle","title":"get_handle","text":"<pre><code>get_handle() -&gt; Union[CffiData, None]\n</code></pre> <p>Gets the underlying low-level CFFI handle this object wraps.</p> <p>Returns:</p> <ul> <li> <code>Union[CffiData, None]</code>           \u2013            <p>CFFI handle or None</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def get_handle(self) -&gt; Union[\"CffiData\", None]:\n    \"\"\"Gets the underlying low-level CFFI handle this object wraps.\n\n    Returns:\n        (Union[CffiData, None]): CFFI handle or None\n    \"\"\"\n    return self._handle\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.OwningCffiNativeHandle.release","title":"release","text":"<pre><code>release() -&gt; None\n</code></pre> <p>Manually decrements the reference counter. Triggers disposal if reference count is down to zero.</p> Source code in <code>src/refcount/interop.py</code> <pre><code>def release(self) -&gt; None:\n    \"\"\"Manually decrements the reference counter. Triggers disposal if reference count is down to zero.\"\"\"\n    self.__dispose_impl(True)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.cffi_arg_error_external_obj_type","title":"cffi_arg_error_external_obj_type","text":"<pre><code>cffi_arg_error_external_obj_type(\n    x: Any, expected_type_id: str\n) -&gt; str\n</code></pre> <p>Build an error message that an unexpected object is in lieu of an expected refcount external ref object.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>object</code>)           \u2013            <p>object passed as an argument to a function but with an unexpected type or type id.</p> </li> <li> <code>expected_type_id</code>               (<code>Optional[str]</code>)           \u2013            <p>Expected identifier for the type of underlying resource being wrapped.</p> </li> </ul> <p>Returns (str): the error message</p> Source code in <code>src/refcount/interop.py</code> <pre><code>def cffi_arg_error_external_obj_type(x: Any, expected_type_id: str) -&gt; str:\n    \"\"\"Build an error message that an unexpected object is in lieu of an expected refcount external ref object.\n\n    Args:\n        x (object): object passed as an argument to a function but with an unexpected type or type id.\n        expected_type_id (Optional[str]): Expected identifier for the type of underlying resource being wrapped.\n\n    Returns (str): the error message\n    \"\"\"\n    if x is None:\n        return \"Expected a 'CffiNativeHandle' but instead got 'None'\"\n    if not is_cffi_native_handle(x):\n        return f\"Expected a 'CffiNativeHandle' but instead got object of type '{type(x)!s}'\"\n    return f\"Expected a 'CffiNativeHandle' with underlying type id '{expected_type_id}' but instead got one with type id '{x.type_id}'\"\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.is_cffi_native_handle","title":"is_cffi_native_handle","text":"<pre><code>is_cffi_native_handle(x: Any, type_id: str = '') -&gt; bool\n</code></pre> <p>Checks whether an object is a ref counting wrapper around a CFFI pointer.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>object</code>)           \u2013            <p>object to test, presumed to be an instance of <code>CffiNativeHandle</code></p> </li> <li> <code>type_id</code>               (<code>Optional[str]</code>, default:                   <code>''</code> )           \u2013            <p>Optional identifier for the type of underlying resource being wrapped.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def is_cffi_native_handle(x: Any, type_id: str = \"\") -&gt; bool:\n    \"\"\"Checks whether an object is a ref counting wrapper around a CFFI pointer.\n\n    Args:\n        x (object): object to test, presumed to be an instance of `CffiNativeHandle`\n        type_id (Optional[str]): Optional identifier for the type of underlying resource being wrapped.\n    \"\"\"\n    if x is None:\n        return False\n    if not isinstance(x, CffiNativeHandle):\n        return False\n    if type_id is None or type_id == \"\":\n        return True\n    return x.type_id == type_id\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.type_error_cffi","title":"type_error_cffi","text":"<pre><code>type_error_cffi(\n    x: Union[CffiNativeHandle, Any], expected_type: str\n) -&gt; str\n</code></pre> <p>DEPRECATED.</p> <p>This function is deprecated; may still be in use in 'uchronia'. Use <code>cffi_arg_error_external_obj_type</code> instead.</p> <p>Build an error message for situations where a cffi pointer handler is not that, or not of the expected type</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Union[CffiNativeHandle, Any]</code>)           \u2013            <p>actual object that is not of the expected type or underlying type for the external pointer.</p> </li> <li> <code>expected_type</code>               (<code>str</code>)           \u2013            <p>underlying type expected for the CFFI pointer handler</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>error message that the caller can use to report the issue</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def type_error_cffi(x: Union[CffiNativeHandle, Any], expected_type: str) -&gt; str:\n    \"\"\"DEPRECATED.\n\n    This function is deprecated; may still be in use in 'uchronia'. Use `cffi_arg_error_external_obj_type` instead.\n\n    Build an error message for situations where a cffi pointer handler is not that, or not of the expected type\n\n    Args:\n        x (Union[CffiNativeHandle, Any]): actual object that is not of the expected type or underlying type for the external pointer.\n        expected_type (str): underlying type expected for the CFFI pointer handler\n\n    Returns:\n        str: error message that the caller can use to report the issue\n    \"\"\"\n    return cffi_arg_error_external_obj_type(x, expected_type)\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.unwrap_cffi_native_handle","title":"unwrap_cffi_native_handle","text":"<pre><code>unwrap_cffi_native_handle(\n    obj_wrapper: Any, stringent: bool = False\n) -&gt; Union[CffiData, Any, None]\n</code></pre> <p>Unwrap a reference counting wrapper and returns its CFFI pointer if it is found (wrapped or 'raw').</p> <p>Parameters:</p> <ul> <li> <code>obj_wrapper</code>               (<code>Any</code>)           \u2013            <p>An object, which will be unwrapped if this is a CFFI pointer, i.e. an instance of <code>CffiData</code></p> </li> <li> <code>stringent</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>[description]. if True an error is raised if obj_wrapper is neither None, a CffiNativeHandle nor an CffiData. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>A CFFI pointer could not be found in the object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[CffiData, Any, None]</code>           \u2013            <p>Union[CffiData,Any,None]: A CFFI pointer if it was found. Returns None or unchanged if not found, and stringent is equal to False. Exception otherwise.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def unwrap_cffi_native_handle(\n    obj_wrapper: Any,\n    stringent: bool = False,\n) -&gt; Union[\"CffiData\", Any, None]:\n    \"\"\"Unwrap a reference counting wrapper and returns its CFFI pointer if it is found (wrapped or 'raw').\n\n    Args:\n        obj_wrapper (Any): An object, which will be unwrapped if this is a CFFI pointer, i.e. an instance of `CffiData`\n        stringent (bool, optional): [description]. if True an error is raised if obj_wrapper is neither None, a CffiNativeHandle nor an CffiData. Defaults to False.\n\n    Raises:\n        Exception: A CFFI pointer could not be found in the object.\n\n    Returns:\n        Union[CffiData,Any,None]: A CFFI pointer if it was found. Returns None or unchanged if not found, and stringent is equal to False. Exception otherwise.\n    \"\"\"\n    # 2016-01-28 allowing null pointers, to unlock behavior of EstimateERRISParameters.\n    # Reassess approach, even if other C API function will still catch the issue of null ptrs.\n    if obj_wrapper is None:\n        return None\n    if isinstance(obj_wrapper, CffiNativeHandle):\n        return obj_wrapper.get_handle()\n    if isinstance(obj_wrapper, FFI.CData):\n        return obj_wrapper\n    if stringent:\n        raise TypeError(\n            \"Argument is neither a CffiNativeHandle nor a CFFI external pointer\",\n        )\n    return obj_wrapper\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.wrap_as_pointer_handle","title":"wrap_as_pointer_handle","text":"<pre><code>wrap_as_pointer_handle(\n    obj_wrapper: Any, stringent: bool = False\n) -&gt; Union[\n    CffiNativeHandle, OwningCffiNativeHandle, GenericWrapper\n]\n</code></pre> <p>Wrap an object, if need be, so that its C API pointer appears accessible via a 'ptr' property.</p> <p>Parameters:</p> <ul> <li> <code>obj_wrapper</code>               (<code>Any</code>)           \u2013            <p>Object to wrap, if necessary</p> </li> <li> <code>stringent</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Throws an exception if the input type is unhandled. Defaults to False.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>neither a CffiNativeHandle nor a CFFI external pointer, nor bytes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[CffiNativeHandle, OwningCffiNativeHandle, GenericWrapper]</code>           \u2013            <p>Union[CffiNativeHandle, OwningCffiNativeHandle, GenericWrapper, None]: wrapped object or None</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def wrap_as_pointer_handle(\n    obj_wrapper: Any,\n    stringent: bool = False,\n) -&gt; Union[CffiNativeHandle, OwningCffiNativeHandle, GenericWrapper]:\n    \"\"\"Wrap an object, if need be, so that its C API pointer appears accessible via a 'ptr' property.\n\n    Args:\n        obj_wrapper (Any): Object to wrap, if necessary\n        stringent (bool, optional): Throws an exception if the input type is unhandled. Defaults to False.\n\n    Raises:\n        TypeError: neither a CffiNativeHandle nor a CFFI external pointer, nor bytes\n\n    Returns:\n        Union[CffiNativeHandle, OwningCffiNativeHandle, GenericWrapper, None]: wrapped object or None\n    \"\"\"\n    # 2016-01-28 allowing null pointers, to unlock behavior of EstimateERRISParameters.\n    # Reassess approach, even if other C API function will still catch the issue of null ptrs.\n    if obj_wrapper is None:\n        return GenericWrapper(None)\n        # return GenericWrapper(FFI.NULL)  # Ended with kernel crashes and API call return, but unclear why\n    if isinstance(obj_wrapper, CffiNativeHandle):\n        return obj_wrapper\n    if isinstance(obj_wrapper, FFI.CData):\n        return OwningCffiNativeHandle(obj_wrapper)\n    if isinstance(obj_wrapper, bytes):\n        return GenericWrapper(obj_wrapper)\n    if stringent:\n        raise TypeError(\n            \"Argument is neither a CffiNativeHandle nor a CFFI external pointer, nor bytes\",\n        )\n    return obj_wrapper\n</code></pre>"},{"location":"reference/refcount/interop/#refcount.interop.wrap_cffi_native_handle","title":"wrap_cffi_native_handle","text":"<pre><code>wrap_cffi_native_handle(\n    obj: Union[CffiData, Any],\n    type_id: str = \"\",\n    release_native: Optional[\n        Callable[[CffiData], None]\n    ] = None,\n) -&gt; Union[DeletableCffiNativeHandle, Any]\n</code></pre> <p>Create a reference counting wrapper around an object if this object is a CFFI pointer.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Union[CffiData, Any]</code>)           \u2013            <p>An object, which will be wrapped if this is a CFFI pointer, i.e. an instance of <code>CffiData</code></p> </li> <li> <code>release_native</code>               (<code>Callable[[CffiData], None]</code>, default:                   <code>None</code> )           \u2013            <p>function to call on deleting this wrapper. The function should have one argument accepting the object handle.</p> </li> <li> <code>type_id</code>               (<code>Optional[str]</code>, default:                   <code>''</code> )           \u2013            <p>An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.</p> </li> </ul> Source code in <code>src/refcount/interop.py</code> <pre><code>def wrap_cffi_native_handle(\n    obj: Union[\"CffiData\", Any],\n    type_id: str = \"\",\n    release_native: Optional[Callable[[\"CffiData\"], None]] = None,\n) -&gt; Union[DeletableCffiNativeHandle, Any]:\n    \"\"\"Create a reference counting wrapper around an object if this object is a CFFI pointer.\n\n    Args:\n        obj (Union[CffiData,Any]): An object, which will be wrapped if this is a CFFI pointer, i.e. an instance of `CffiData`\n        release_native (Callable[[CffiData],None]): function to call on deleting this wrapper. The function should have one argument accepting the object handle.\n        type_id (Optional[str]): An optional identifier for the type of underlying resource. This can be used to usefully maintain type information about the pointer/handle across an otherwise opaque C API. See package documentation.\n    \"\"\"\n    if isinstance(obj, FFI.CData):\n        return DeletableCffiNativeHandle(\n            obj,\n            release_native=release_native,\n            type_id=type_id,\n        )\n    return obj\n</code></pre>"},{"location":"reference/refcount/putils/","title":"refcount.putils","text":""},{"location":"reference/refcount/putils/#refcount.putils","title":"putils","text":"<p>Platform specific helpers to manage locating native dynamic libraries.</p> <p>This module hosts features similar to https://github.com/rdotnet/dynamic-interop-dll/blob/main/DynamicInterop/PlatformUtility.cs</p> <p>Functions:</p> <ul> <li> <code>augment_path_env</code>             \u2013              <p>Build a new list of directory paths, prepending prior to an existing env var with paths.</p> </li> <li> <code>build_new_path_env</code>             \u2013              <p>Propose an update to an existing environment variable, based on the path(s) specified in another environment variable. This function is effectively meant to be useful on Windows only.</p> </li> <li> <code>find_full_path</code>             \u2013              <p>Find the full path of a library in under the python.</p> </li> <li> <code>library_short_filename</code>             \u2013              <p>Based on the library name, return the platform-specific expected library short file name.</p> </li> <li> <code>update_path_windows</code>             \u2013              <p>If called on Windows, append an environment variable, based on the path(s) specified in another environment variable. This function is effectively meant to be useful on Windows only.</p> </li> </ul>"},{"location":"reference/refcount/putils/#refcount.putils.augment_path_env","title":"augment_path_env","text":"<pre><code>augment_path_env(\n    added_paths: Union[str, List[str]],\n    subfolder: Optional[str] = None,\n    to_env: str = \"PATH\",\n    prepend: bool = False,\n) -&gt; str\n</code></pre> <p>Build a new list of directory paths, prepending prior to an existing env var with paths.</p> <p>New paths are prepended only if they do already exist.</p> <p>Parameters:</p> <ul> <li> <code>added_paths</code>               (<code>Union[str, List[str]]</code>)           \u2013            <p>paths prepended</p> </li> <li> <code>subfolder</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Optional subfolder name to append to each in path prepended. Useful for 64/32 bits variations. Defaults to None.</p> </li> <li> <code>to_env</code>               (<code>str</code>, default:                   <code>'PATH'</code> )           \u2013            <p>Environment variable with existing Paths to start with. Defaults to 'PATH'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Content (set of paths), typically for a updating/setting an environment variable</p> </li> </ul> Source code in <code>src/refcount/putils.py</code> <pre><code>def augment_path_env(\n    added_paths: Union[str, List[str]],\n    subfolder: Optional[str] = None,\n    to_env: str = \"PATH\",\n    prepend: bool = False,\n) -&gt; str:\n    \"\"\"Build a new list of directory paths, prepending prior to an existing env var with paths.\n\n    New paths are prepended only if they do already exist.\n\n    Args:\n        added_paths (Union[str,List[str]]): paths prepended\n        subfolder (str, optional): Optional subfolder name to append to each in path prepended. Useful for 64/32 bits variations. Defaults to None.\n        to_env (str, optional): Environment variable with existing Paths to start with. Defaults to 'PATH'.\n\n    Returns:\n        str: Content (set of paths), typically for a updating/setting an environment variable\n    \"\"\"\n    path_sep = os.pathsep\n    if isinstance(added_paths, str):\n        added_paths = [added_paths]\n    prior_path_env = os.environ.get(to_env)\n    prior_paths = prior_path_env.split(path_sep) if prior_path_env is not None else []\n\n    def _my_path_join(x: str, subfolder: str):  # avoid trailing path separator  # noqa: ANN202\n        if subfolder is not None and subfolder != \"\":\n            return os.path.join(x, subfolder)\n        return x\n\n    if subfolder is not None:\n        added_paths = [_my_path_join(x, subfolder) for x in added_paths]\n    added_paths = [x for x in added_paths if os.path.exists(x)]\n    new_paths = (added_paths + prior_paths) if prepend else (prior_paths + added_paths)\n    # TODO: check for duplicate folders, perhaps.\n    return path_sep.join(new_paths)\n</code></pre>"},{"location":"reference/refcount/putils/#refcount.putils.build_new_path_env","title":"build_new_path_env","text":"<pre><code>build_new_path_env(\n    from_env: str = \"LIBRARY_PATH\",\n    to_env: str = \"PATH\",\n    platform: Optional[str] = None,\n) -&gt; str\n</code></pre> <p>Propose an update to an existing environment variable, based on the path(s) specified in another environment variable. This function is effectively meant to be useful on Windows only.</p> <p>Parameters:</p> <ul> <li> <code>from_env</code>               (<code>str</code>, default:                   <code>'LIBRARY_PATH'</code> )           \u2013            <p>name of the source environment variable specifying the location(s) of custom libraries to load. Defaults to 'LIBRARY_PATH'.</p> </li> <li> <code>to_env</code>               (<code>str</code>, default:                   <code>'PATH'</code> )           \u2013            <p>environment variable to update, most likely the Windows PATH env var. Defaults to 'PATH'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>the proposed updated content for the 'to_env' environment variable.</p> </li> </ul> Source code in <code>src/refcount/putils.py</code> <pre><code>def build_new_path_env(\n    from_env: str = \"LIBRARY_PATH\",\n    to_env: str = \"PATH\",\n    platform: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Propose an update to an existing environment variable, based on the path(s) specified in another environment variable. This function is effectively meant to be useful on Windows only.\n\n    Args:\n        from_env (str, optional): name of the source environment variable specifying the location(s) of custom libraries to load. Defaults to 'LIBRARY_PATH'.\n        to_env (str, optional): environment variable to update, most likely the Windows PATH env var. Defaults to 'PATH'.\n\n    Returns:\n        str: the proposed updated content for the 'to_env' environment variable.\n    \"\"\"\n    platform = sys.platform if platform is None else platform\n    path_sep = os.pathsep\n    shared_lib_paths = os.environ.get(from_env)\n    if shared_lib_paths is not None:\n        # We could consider a call to a logger info here\n        subfolder = _win_architecture()\n        shared_lib_paths_vec = shared_lib_paths.split(path_sep)\n        return augment_path_env(shared_lib_paths_vec, subfolder, to_env=to_env)\n    print(  # noqa: T201\n        f\"WARNING: a function was called to look for environment variable '{from_env}' to update the environment variable '{to_env}', but was not found. This may be fine, but if the package fails to load because a native library is not found, this is a likely cause.\",\n    )\n    prior_path_env = os.environ.get(to_env)\n    if prior_path_env is not None:\n        return prior_path_env\n    return \"\"\n</code></pre>"},{"location":"reference/refcount/putils/#refcount.putils.find_full_path","title":"find_full_path","text":"<pre><code>find_full_path(\n    name: str, prefix: Optional[str] = None\n) -&gt; Union[str, None]\n</code></pre> <p>Find the full path of a library in under the python.</p> <pre><code>installation directory, or as devised by ctypes.find_library\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Library name, e.g. 'R' for the R programming language.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[str, None]</code>           \u2013            <p>Union[str, None]: First suitable library full file name.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from refcount.putils import *\n&gt;&gt;&gt; find_full_path(\"gfortran\")\n'/home/xxxyyy/anaconda3/envs/wqml/lib/libgfortran.so'\n&gt;&gt;&gt; find_full_path(\"R\")\n'libR.so'\n</code></pre> Source code in <code>src/refcount/putils.py</code> <pre><code>def find_full_path(name: str, prefix: Optional[str] = None) -&gt; Union[str, None]:\n    \"\"\"Find the full path of a library in under the python.\n\n        installation directory, or as devised by ctypes.find_library\n\n    Args:\n        name (str): Library name, e.g. 'R' for the R programming language.\n\n    Returns:\n        Union[str, None]: First suitable library full file name.\n\n    Examples:\n        &gt;&gt;&gt; from refcount.putils import *\n        &gt;&gt;&gt; find_full_path(\"gfortran\")\n        '/home/xxxyyy/anaconda3/envs/wqml/lib/libgfortran.so'\n        &gt;&gt;&gt; find_full_path(\"R\")\n        'libR.so'\n    \"\"\"\n    full_libpath = None\n    if prefix is None:\n        prefix = sys.prefix\n    if name is None:\n        return None\n    lib_short_fname = library_short_filename(name)\n    prefixed_lib_pat = os.path.join(prefix, \"lib*\", lib_short_fname)\n    prefixed_libs = glob(prefixed_lib_pat)\n    if prefixed_libs:\n        full_libpath = prefixed_libs[0]\n    if not full_libpath:\n        full_libpath = ctypes_find_library(name)\n    return full_libpath\n</code></pre>"},{"location":"reference/refcount/putils/#refcount.putils.library_short_filename","title":"library_short_filename","text":"<pre><code>library_short_filename(\n    library_name: Optional[str],\n    platform: Optional[str] = None,\n) -&gt; str\n</code></pre> <p>Based on the library name, return the platform-specific expected library short file name.</p> <p>Parameters:</p> <ul> <li> <code>library_name</code>               (<code>str</code>)           \u2013            <p>name of the library, for instance 'R', which results out of this function  as 'libR.so' on Linux and 'R.dll' on Windows</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>invalid argument</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>expected short file name for the library, for this platform</p> </li> </ul> Source code in <code>src/refcount/putils.py</code> <pre><code>def library_short_filename(library_name: Optional[str], platform: Optional[str] = None) -&gt; str:\n    \"\"\"Based on the library name, return the platform-specific expected library short file name.\n\n    Args:\n        library_name (str): name of the library, for instance 'R', which results out of this\n            function  as 'libR.so' on Linux and 'R.dll' on Windows\n\n    Raises:\n        ValueError: invalid argument\n\n    Returns:\n        str: expected short file name for the library, for this platform\n    \"\"\"\n    if platform is None:\n        platform = sys.platform\n    if library_name is None:\n        raise ValueError(\"library_name cannot be None\")\n    if platform == \"win32\":\n        return f\"{library_name}.dll\"\n    if platform == \"linux\":\n        return f\"lib{library_name}.so\"\n    if platform == \"darwin\":\n        return f\"lib{library_name}.dylib\"\n    raise NotImplementedError(f\"Platform '{platform}' is not (yet) supported\")\n</code></pre>"},{"location":"reference/refcount/putils/#refcount.putils.update_path_windows","title":"update_path_windows","text":"<pre><code>update_path_windows(\n    from_env: str = \"LIBRARY_PATH\", to_env: str = \"PATH\"\n) -&gt; None\n</code></pre> <p>If called on Windows, append an environment variable, based on the path(s) specified in another environment variable. This function is effectively meant to be useful on Windows only.</p> <p>Parameters:</p> <ul> <li> <code>from_env</code>               (<code>str</code>, default:                   <code>'LIBRARY_PATH'</code> )           \u2013            <p>name of the source environment variable specifying the location(s) of custom libraries to load. Defaults to 'LIBRARY_PATH'.</p> </li> <li> <code>to_env</code>               (<code>str</code>, default:                   <code>'PATH'</code> )           \u2013            <p>environment variable to update, most likely the Windows PATH env var. Defaults to 'PATH'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/refcount/putils.py</code> <pre><code>def update_path_windows(from_env: str = \"LIBRARY_PATH\", to_env: str = \"PATH\") -&gt; None:\n    \"\"\"If called on Windows, append an environment variable, based on the path(s) specified in another environment variable. This function is effectively meant to be useful on Windows only.\n\n    Args:\n        from_env (str, optional): name of the source environment variable specifying the location(s) of custom libraries to load. Defaults to 'LIBRARY_PATH'.\n        to_env (str, optional): environment variable to update, most likely the Windows PATH env var. Defaults to 'PATH'.\n\n    Returns:\n        None\n    \"\"\"\n    if sys.platform == \"win32\":\n        os.environ[to_env] = build_new_path_env(from_env, to_env, sys.platform)\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}